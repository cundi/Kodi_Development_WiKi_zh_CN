# 3 皮肤开发手册
Kodi includes a GUI library that allows you to skin/change everything you see in Kodi, from the images, the sizes and positions of all controls, colours, fonts, and text, through to altering navigation and even adding new functionality  

Kodi包含了一个允许你编写皮肤／改变一切在Kodi中见到的GUI库，从图片、到所有control的大小和位置、色彩、字体、文本，到切换导航甚至是添加新功能。  

The skin system is quite complex, and this portion of the manual is dedicated to providing in depth information on how it all works, along with tips to make the experience a little more pleasant.  

皮肤系统很复杂，手册中的这一部分专门用来提供深入的皮肤系统工作原理信息，多使用提示也让读者拥有更好一些的体验。  

If you are just getting started with skinning Kodi, then it is suggested that the best way to learn is by modifying one of the many existing skins that are available. The default skin, Confluence, includes almost all the various tricks and features that make the Kodi skinning engine so powerful, so is an ideal place to start. You may wish to start by having a look [through the tutorial section on skinning Kodi](http://kodi.wiki/view/XBMC_Skinning_Tutorials) as well as the ["Skinning Kodi"](http://kodi.wiki/view/Skinning_XBMC) article, and try modifying a window or two by adding a button, or altering the textures or layout.  

如果你是刚接触Kodi皮肤开发，建议的最佳学习方式是修改多个现有可用的皮肤中的一个。默认的皮肤是Confluence, 该皮肤包含了几乎全部的让Kodi皮肤引擎变得强大的技巧和功能，所以这也是一个理想入门的切入点。你可以从浏览[了解Kodi皮肤教程章节](http://kodi.wiki/view/XBMC_Skinning_Tutorials)，以及关于["开发Kodi皮肤"](http://kodi.wiki/view/Skinning_XBMC)的文章开始，然后尝试通过添加一个按钮，或者切换素材、布局来修改一两个窗口。  

## 1 Anatomy of a Skin 解构皮肤

Kodi skins, once installed, are located in [userdata](http://kodi.wiki/view/Userdata) addons folder. This is the folder where all skins are placed and listed.  

Kodi的皮肤在安装后被放置于[userdata](http://kodi.wiki/view/Userdata)这个扩展目录下。这也是所有皮肤被放置和列出的地方。  

Any additional skins you create, or download from, or be installed via zip, Kodi will load and ask you if you would like to load the skin and also allow you to load them up from within the Appearance Settings. It is suggested that if you want to make your own skin, then starting by copying an existing skins files over into a new folder (let's say skin/myskin) is a good place to start. You can then edit each of the files as you become more familiar with the skinning system.  

你创建的或者下载的、通过zip安装的任何额外皮肤，Kodi会加载它们并询问你希望使用的皮肤，而且还允许你把这些皮肤载入到设置 Appearance 中。我有一个对想要编写自定义的皮肤建议，从复制已有皮肤文件到一个新的文件夹便是一个良好的开端。在你对皮肤系统越来越熟悉后你就可以编辑每一个文件了。  

Each skin folder contains several subdirectorys, and one file:  

每个皮肤都包含多个子目录，以及一个文件：  

#### myskin/720p
This is a resolution-specific directory. Kodi can run in multiple resolutions, and thus can use different files for some resolutions (as there is a big difference between NTSC at 720x480 pixels and 1080i at 1920x1080 pixels!)  

这是一个特定分辨率的目录。Kodi可以运行在多个分辨率之下，因此也能够为某些分辨率使用不同文件（就像NTSC的720x480像素和1080i的1920x1080像素之间有着很大的不同）  

#### myskin/backgrounds
optional folder containing the background images used in the skin  

可选的包含了用在皮肤中的背景图片的文件夹  

#### myskin/colors
contains a defaults.xml file which is used to define the colours used in the skin  

包含了一个defaults.xml文件，被用作定义用于皮肤的色彩  

#### myskin/font
This subdirectory contains all fonts used by the skin. you can add/replace fonts here  

用于皮肤的包含所有字体的子目录。  

#### myskin/language
contains several subfolders for each language (English/strings.po). you can define strings used in your skin in this file.  

包含了针对每种语言（English/strings.po）的多个子文件夹。你可以在这个文件中定义可用于皮肤的字符串。  

#### myskin/media
This subdirectory contains all the media files (.png/.gif/.jpg...) You can replace/edit these as you like.  

包含所有媒体文件（.png/.gif/.jpg...）的子目录，你可以按照需求进行替换／编辑。  

#### myskin/resources
place your icon.png (a 256x256 or 512x512 png image for your skin), fanart.jpg (a 1280x720 or 1920x1080 jpeg fanart image for your skin) and 10 jpeg screenshots (1280x720) of your skin in here. Name them screenshot01.jpg, screenshot02.jpg ect.  

该目录用于放置自定义的icon.png（用于自定义皮肤的一个256x256 或者512x512 png格式图片） ，fanart.jpg（），以及10张jpeg格式皮肤截图（1280x720）。这些截图可以命名为screenshot01.jpg, screenshot02.jpg等等。  

#### [myskin/addon.xml](http://kodi.wiki/view/Addon.xml)
This contains the information that Kodi uses to find the other files that Kodi requires to describe it's skin. It also contains credits information, and versioning information.  

该文件包含了Kodi用来查找其它文件的信息。它还包含了版权信息，和版本信息。  

#### myskin/LICENSE.txt
we recommend to include a Creative Commons license file in your skin: http://creativecommons.org/licenses/  
我们推荐你在皮肤中包括一个创作共用许可文件： http://creativecommons.org/licenses/  

[See here for the order in which it looks for skin files. ](http://kodi.wiki/view/Addon.xml#Skin_specific_elements)


## 2 Skin Themes 皮肤主题

All the basic media files for a skin should be compressed into the Textures.xbt file, and placed in the media/ folder. You can use the tool Texturepacker for this. All the images that make up the default skin theme should be in the Textures.xbt file.  

In addition to this, Kodi allows other .xbt files in the media/ folder, each one representing a different theme for your skin. For instance, you could tint all your main textures a red colour, and create a new theme package Red.xbt. This gives users more choice in the look of a particular skin, and only the textures change when you change themes – the layout stays the same. If the user has selected a theme, then when a control requires a texture, Kodi will first look in the <themename>.xbt file for the texture. It will fall back to the Textures.xbt file if <themename>.xbt doesn't contain the image. This means that the theme .xbt files need only contain the changed textures – all other textures will fallback to using Textures.xbt as usual.  

A suggested method of creating a theme is as follows:  

1. Run Texturepacker.exe on the folder containing the default texture files, to generate Textures.xbt as you would normally do.
2. Identify the textures you wish to have themed and copy them to a separate folder.
3. Create a separate folder for each theme outside of your normal skin work area, and place the altered copies of each of the textures in them.
3. Run Texturepacker.exe on each of the theme folders created in step 3 to create the themed .xbt files (note you can use the -output switch with Texturepacker.exe to name the theme appropriately).
5. Place Textures.xbt and each of the theme .xbt files in the media/ folder of your skin. Kodi will automatically pick them up.

##3 addon.xml

*Main page: [addon.xml](http://kodi.wiki/view/Addon.xml)*  

## 4 Windows 窗口

### 4.1 Window Structure 窗口结构

### 4.2 About the Window XML Files  窗口XML文件

Each window in an Kodi skin is represented by a single .xml file. [See here for a list of the standard windows and links to their .xml files](http://kodi.wiki/view/Window_IDs).  

Kodi皮肤中的每个窗口都由单个的.xml文件表示。[此处参见标准窗口列表和](http://kodi.wiki/view/Window_IDs)。  

The important thing to remember is that each window has a unique identifying name. This is how Kodi identifies the window from within the source code. The window names are all listed in the Appendix I: List of Windows.  

要记住的重要事情是每个窗口都拥有一个唯一的标识名称。这就是Kodi如何从源码中识别窗口的依据。窗口名称全部在附录I中列出：窗口列表。  

Each .xml file has the same basic structure – it starts with some heading information that pertains to the window as a whole, and then contains a <controls> block within which all the controls that describe the window are defined. Many of the controls within each window should have a unique id's, unless they're just used as images or labels where navigation is unimportant and Kodi does not need to be able to identify them uniquely.  

每个xml文件都具有相同的基本结构——以可以应用到窗口全局的一些头信息开始，然后是窗口的全部控制描述定义包含在<controls>块中。每个窗口的多个控制应该拥有一个唯一的id，除非他们刚好被用做图片或者label，同时导航不是那么重要而且Kodi也不需要标识它们的唯一性。  

### 4.3 Window Header 窗口首部

```xml
<?xml version="1.0" encoding="UTF-8"?>
<window>
  <onload>RunScript(script.foobar)</onload>
  <onunload>SetProperty(foo,bar)</onunload>
  <defaultcontrol always="false">2</defaultcontrol>
  <menucontrol>9000</menucontrol>
  <backgroundcolor>0xff00ff00</backgroundcolor>
  <views>50,51,509,510</views>
  <visible>Window.IsActive(Home)</visible>
  <animation effect="fade" time="100">WindowOpen</animation>
  <animation effect="slide" end="0,576" time="100">WindowClose</animation>
  <zorder>1</zorder>
  <coordinates>
    <left>40</left>
    <top>50</top>
    <origin x="100" y="50">Window.IsActive(Home)</origin>
  </coordinates>
  <previouswindow>MyVideos</previouswindow>
  <controls>
    <control>
    </control>
    ....
  </controls>
</window>
```

One thing to note is that all tag names are lower case. **XML tag names are case sensitive!**  

要注意的一点是所有的标签名称都是小写的。**XML标签名称是大小写敏感的！**

The header contains the following tags:  

header包含以下标签：  

**onload**  
Optional: the build-in function to execute when the window opens  
可选：窗口打开时要执行的内建函数

**onunload**  
Optional: the build-in function to execute when the window closes  
可选：窗口关闭时会执行的内建函数

**defaultcontrol**  
This specifies the default control of the window. This is the id of the control that will receive focus when the window is first opened. Note that most Kodi windows save the current focus when you leave the window, and will return to the last focused item when you return to a window. This behaviour can be stopped by specifying the attribute always="true".  

该标签为窗口执行的默认控制。这是一个窗口在第一次被打开时会接受聚焦的控制id。注意大多数的Kodi窗口会在你离开窗口时保留当前的聚焦，而且会在你回到窗口时返回上次的聚焦。这个行为可以通过指定属性 always="true 来停止。  

**menucontrol**  
This specifies the control that will be focused when the users presses the 'menu' / 'm' button.  
该标签指定了在用户按下‘菜单’／‘m'按钮时需要被聚焦的control。  

**backgroundcolor**  
Specifies whether the window needs clearing prior to rendering, and if so which colour to use. Defaults to clearing to black. Set to 0 (or 0x00000000) to have no clearing at all. If your skin always renders opaque textures over the entire screen (eg using a backdrop image or multiple backdrop images) then setting the background color to 0 is the most optimal value and may improve performance significantly on slow GPUs.  

该标签指定了窗口是否需要清空之前的设置以便进行渲染，如果需要的话，应该使用哪一种色彩。默认清空为黑色。设置为0（或者or 0x00000000）不执行任何清空。如果你的皮肤一直都是在整个屏幕（比如，使用背景图片或者多个背景图片）上渲染不透明材质，那么可以设置背景色彩为0为最优值，这也可以在慢速GPU上显著提高性能。  

**visible**  
Specifies the conditions under which a dialog will be visible. Kodi evaluates this at render time, and shows or hides a dialog depending on the evaluation of this tag. [See here for more details](http://kodi.wiki/view/Conditional_Visibility). **Applies only to type="dialog" windows**.  

指定对话框可见的条件。Kodi在渲染时对此标签进行计算，并基于对该标签计算的结果显示或者隐藏对话框。[此处有更多详细说明](http://kodi.wiki/view/Conditional_Visibility).**仅在对窗口应用type="dialog"**。  

**animation**  
Specifies the animation effect to perform when opening or closing the window. [See here for more details.](http://kodi.wiki/view/Animating_Your_Skin)  

指定在打开或者关闭窗口时要执行的动画效果。[此处有更多详细说明](http://kodi.wiki/view/Animating_Your_Skin)  s

**zorder**  
This specifies the “depth” that the window should be drawn at. Windows with higher zorder are drawn on top of windows with lower z-order. All dialogs by default have zorder 1, so if you have a particular dialog that you want underneath all others, give it a zorder of 0. (Note that the normal render order is: The base window, then the overlays (music + video), then dialogs. <zorder> only effects the rendering of the dialogs.  

该标签指定了窗口应该被放置的“景深”。更高zorder的窗口放置于低z-order之上。所有的对话框的默认zorder为1，所以如果你有一个想要放置在其他所有窗口之下的特殊对话框，那么可以zorder设置为0.（注意，常规的渲染顺序是：首先是基本窗口，然后是覆盖层（音乐＋视频））

**coordinates 坐标**  
This block is used to specify how Kodi should compute the coordinates of all controls.  
此标签块用来指定Kodi如何计算所有控制的坐标。  

**left**  
Sets the horizontal “origin” position of the window. Defaults to 0 if not present.  
设置窗口的水平“原始”位置。如果该标签为设置默认坐标值为0.  

**top**  
Sets the vertical “origin” position of the window. Defaults to 0 if not present.  
设置窗口的垂直“原始”位置。如果该标签为设置默认坐标值为0.  

**origin**  
Sets a conditional origin for the window. The window will display at (x,y) whenever the origin condition is met. You can have as many origin tags as you like – they are evaluated in the order present in the file, and the first one for which the condition is met wins. If none of the origin conditions are met, we fall back to the <left> and <top> tags.  

为窗口设置有条件的origin。不论origin是什么窗口都会显示在（x，y）。你可以按照个人喜好设置多个origin——它们被计算以出现在文件中，遇到的第一个标签被选中。如果没有碰到origin条件，则回滚到 <left> 和 <top>标签。  

**previouswindow**  
This can be used to specify a window to force Kodi to go to on press of the Back button. Normally Kodi keeps a “window stack” of previous windows to handle this. This tag allows you to override this behaviour. The value is the name of the window.  

该标签用来指定按下返回按钮时Kodi所执行的窗口。通常Kodi保存一个前面“窗口”的栈来处理这个问题。该标签允许你重写默认行为。值为窗口的名称。  
**views**  
This tag lets you use view id's beyond 50 to 59 it also lets you set the order in which they cycle with the change view button in the skin. Only useful in My<Foo>.xml windows.  

该标签让你使用大于50到59点视图id，而且你还可以

**controls**  
This is the block the defines all controls that will appear on this window.  
该标签定义了所有会出现当前窗口的标签块。  

### 4.3.1 The Different Types of Controls
Kodi supports many different types of controls.  
Kodi 支持多种类型的控制。  

[Click here for the control types and what they all do.](http://kodi.wiki/view/Controls)  
[点击此处查看控制类型，以及它们所实现的内容](http://kodi.wiki/view/Controls)  

Some of these controls are required on specific windows, as they're necessary for that window to perform it's duty, or, the contents of the control are only valid on a particular window. The mandatory controls for each window are listed here. While the controls are mandatory, you can ofcourse move them about and change their appearance within the windows to your hearts content!  

其中部分控制需要特定的窗口，

### 4.3.2 Adding Extra Windows 添加额外窗口
All of the windows in the [window list](http://kodi.wiki/view/Window_IDs) are defined within the executable of Kodi itself, as most of them have a specific purpose. However, the skinner may add extra windows as and when they are needed or wanted. The only restriction to this is that only controls that do not require specific source code to operate can be used. This is not too much of a restriction though, as many skinners have found out.  

所有的窗口列表中的窗口都定义在可执行的Kodi内部，它们中的大部分都用于特定的目的。不过，

To add an extra window, all you need to do is design up the window's .xml file in the usual way, assign it an <id> within the 1100–1199 range (see window list), and then name the file customN.xml, where N is a number or name. You can have as many as you like, as long as they have unique <id>'s, and are named differently. Then just define the type of window you want, the coordinate system and so on, add the controls and setup the navigation. To activate your window, you can do it by adding a button control elsewhere in the skin, or you can get it to popup on a press of the controller or remote via keymap.xml and so on. Basically you just need to run ActivateWindow(id) from a suitable place.  

要添加额外的窗口，你所需要的就是依照常规设计窗口的xml文件，并对窗口赋予一个1100-1199范围内的 <id>，然后把文件命名为customN.xml，这里N是一个数字或者名称。随便你写多少个窗口都可以，只要它们都有唯一的<id>，并且使用不同的命名。再然后定义你所希望的窗口类型，添加控制、设置导航、以及坐标系统等等。为了激活你的窗口，你可以通过在皮肤中其它地方添加一个按钮控制来实现它，或者

## 5 Includes 继承

The other special (and arguably the most important skinning file of all) is includes.xml. This is, as its title suggests, a place from which you can define the default look, size, and positioning of controls, to save you replicating many of the control's attributes throughout the window .xml files. For instance, you can setup the size, and textures used for a button control, thus allowing you to leave those details out in the rest of the skin files, unless of course you want to override the default look or size etc. in a particular window.  

比较特别（可以说是所有皮肤文件中最为重要的）的是includes.xml。就像标题所暗示的那样，这是一个允许你定义默认外观、吃顿、以及控制位置的地方，它能够通过窗口的.xml文件免去你去重复很多的控制属性。例如，你可以为按钮控制设置size、用于按钮控制的texture，这样就允许你在剩余的皮肤文件中把这些细节暴露出来，当然除非你想要在部分窗口中重写默认的外观和尺寸等等。  

This is extremely valuable as it allows you to greatly simplify a lot of the work in building a skin. For one thing, it means that once you have include files setup, many of the default parameters for a different resolution can be done by just altering the parameters within the include file(s) for the different resolution.  

这种机制非常有价值，因为它让你极大的简化了很多的构建皮肤工作。要说明的一点是，它意味着你一旦你设置了include文件，很多的不同分辨率的默认参数就可以在include文件中为不同的分辨率

You can infact have more than one include file - you can specify the file attribute when including from a different file, allowing you to have an include file dedicated to a particular set of attributes.  

事实上你可以拥有不止一个include文件——你可以在继承不同的文件时指定文件属性，

The layout of an includes file is as follows.  

include文件的布局如下。  

```
  <?xml version="1.0" encoding="UTF-8"?>
  <includes>
    <include name="whitetext">
      <textcolor>ffffffff</textcolor>
    </include>
    <include file="listdefaults.xml" />
    <include condition="Skin.HasSetting(extras) file="includes_extras.xml" />
    <default type="button">
      <include>whitetext</include>
    </default>
    <constant name="leftedge">50</constant>
  </includes>
```

You'll notice in the above example that we have 4 different types of includes. The first <include> tag basically allows a substitution of the tags underneath it whenever it occurs. For instance, if in a window .xml file you have this:  

你会注意到上面的例子中我们拥有4个不同类型的include。第一个<include> 标签允许你在不论它在何时出现都可以在标签下进行替换。例如，假设你的 window .xml文件包含以下内容：  

```xml
  <control type="togglebutton">
    <include>whitetext</include>
    ... other tags go here
  </control>
```

Then it would substitute the <textcolor> tag for where the include tag is. You can have as many includes as you like, and as many tags can be inside an include - even complete controls, or complete control groups.  

那么它会在include标签出现的地方替换掉<textcolor>标签。随便你用多少个include都可以，

The second <include> tag in the example demonstrates how to include from a different file. As there is no include name specified, it will include the contents of the entire file at that point.  

例子中的第二个<include> 标签说明了从一个不同文件执行继承。

The <default> tag is similar to an include, except that it is used in every control of that type - even if you don't specify that the control is to use includes. Thus every buttoncontrol will have the whitetext include in it. Note that you can override this by specifying the <textcolor> tag in the buttoncontrol.  

<default>标签类似于include，除了它可以用在每一种类型的控制——即使你没有指定控制用于include。因此每一个按钮控制都会用在include中使用whitetext。注意你可以通过指定按钮控制中的 <textcolor> 标签来重写

And finally, the <constant> tag allows you to define a numeric (floating point) constant by name for use in place of numeric values (<left>, height="" etc.) would otherwise be used. This allows alignment of items using the same position values which can then easily be altered in one place.   

最后，<constant> 标签允许你

## 5.1 Use params in includes 在继承中使用参数

As of Kodi 15.0 Isengard you get is the ability to pass arbitrary parameters to your includes and then use these values anywhere within the include body. Just so you don't have to copy/paste huge chunks of XML anymore in order to change just a value or two. Includes are now roughly equivalent to "procedures" in programming languages. Here's the final syntax that has been included in Kodi.  

从Kodi 15.0 Isengard开始你就可以传递任意参数到继承中，然后在继承到主体内部任何地方使用这些值。

Include definitions are still written within <includes> tag, usually in includes.xml. But they can now accept parameters:  

继承的定义依旧可以写在<includes>标签中，通常位于includes.xml中。现在它们能够接受参数了：  

```xml
<include name="MyControl">
    <param name="id"/>
    <param name="left" default="120"/>
    <param name="top">225</param>
    <definition>
        <control type="image" id="$PARAM[id]">
            <left>$PARAM[left]</left>
            <top>$PARAM[top]</top>
            <width>370</width>
            <height>40</height>
            <texture>foo.png</texture>
        </control>
    <definition>
</include>
```

Here, the first part is called parameter list and is specified using <param> tags. When it is present, include body that follows it should be enclosed within <definition> tag. At the moment, parameter list is optional and is mainly used for specifying default values for parameters (such as 120 and 225 above), but is otherwise not mandatory.  

这里，第一部分称作参数列表，而且通过使用 <param> 标签指定。当 <param> 出现时，其后的include主体应该包含在<definition> 标签内。此刻，参数列表可供选用，而且这些参数主要用来为参数指定默认值（比如上面的120到225），反之则是强制的。  

The above include can be called like this:  

上面的继承可以像这样调用：  

```xml
<include content="MyControl">
    <param name="id" value="52"/>
    <param name="left">300</param>
</include>
```

This has the exact same effect as if you've written this instead:  

如果你写的是下面这种结构，其效果仍旧是一样的：  

```xml
<include content="MyControl">
    <control type="image" id="52">
        <left>300</left>
        <top>225</top>
        <width>370</width>
        <height>40</height>
        <texture>foo.png</texture>
    </control>
</include>
```

and called it (old-style) like this:  

你还可以像这样（旧式风格）调用这个继承：

```xml
<include>MyControl</include>
```

only without added benefits.  
这样做只是丢失了加入到新版本特性的好处。  

Any appropriate value can be passed as parameter in the new **include call**, including $INFO labels, $LOCALIZE, $VARs, constants, etc. Empty string (value="") can also be passed, for example to override a non-empty default value set in the include definition.  

任何适当的值都可以作为参数传递到新的**继承调用**中，导入 $INFO 标记，$LOCALIZE, $VAR，常量等等。还可传递空字符串（value=""），例如在重写一个设置在继承定义中的非空默认值。  

Default values are used as replacement when their parameters are not passed in the include call.  

当它们的值在include调用汇中没有传递时，默认值被替换。  

$PARAM references can be specified within both tag values and attributes inside include body, and are expanded to either actual value passed (if it was passed), default value (if set) or empty string, in that order.  

$PARAM的引用可以同时在标签值和include主体内部的属性指定，

Parameters without default values (such as id above) are specified for better readability and documentation purposes only, but are otherwise not necessary and can be omitted. This is really a matter of style, and some skinners might prefer writing explicit parameter lists to specify all parameters referenced in the include body. It's a good practice though, as explicit parameter lists might be better utilized in the future versions of Kodi.  

没有默认值的参数（比如上面的id）的指定仅仅基于更好的可读性和文档的考虑，否则就是没有必要，而且会被忽略掉。这真的只是一种风格问题而已，有些皮肤开发者更愿意编写显示参数列表，

If there are no <param> tags at all, <definition> can be omitted too. This leads to even shorter syntax:  

如果根本没有<param>标签，定义也会被忽略。

```xml
<include name="MyControl">
    <control type="image" id="$PARAM[id]">
        <left>$PARAM[left]</left>
        <top>$PARAM[top]</top>
        <width>370</width>
        <height>40</height>
        <texture>foo.png</texture>
    </control>
</include>
```

Includes can call other (nested) includes and even pass them exact parameter values that they've got themselves. This is called **parameter forwarding**.  

继承可以调用其它的（嵌套）继承，设置是将它们完全做为参数值进行传递，

```xml
<include name="MyControl">
    ...
    <include name="MyOtherControl">
        <param name="label">$INFO[Player.Title]</param>
        <param name="label2" value="x:$PARAM[left]; y:$PARAM[top]"/>
        <param name="color" value="$PARAM[color]"/>     <!-- forwarding -->
        <param name="id" value="$PARAM[scrollbarid]"/>  <!-- forwarding -->
    </include>
    ...
</include>
```

Here, $PARAM[color] and $PARAM[scrollbarid] will be forwarded to MyOtherControl only if parameters color and scrollbarid have actually been passed to MyControl, otherwise the default values for color and id (if set in MyOtherControl) will be used instead in the body of MyOtherControl. Composite values containing other characters (such as label2) are not considered as "true" forwarding and always override any default value set in the nested include, even when they expand to empty strings.  

这里，$PARAM[color] 和 $PARAM[scrollbarid] 仅在参数的color和scrollbarid实际被传递到MyControl时，才会转发到MyOtherControl，否则color到默认值和id（如果设置在MyOtherControl中的话）将会被使用，而不是MyOtherControl主体中所定义的。合成值包含其它字符（比如label2）

## 5.2 Variables 变量

Variables make it easier to use conditional infolabels. You can define them in Includes.xml, or to keep them separate, you can place them in another file which is included in Includes.xml. You can include a file in Includes.xml by adding a line like this:  

变量让包含条件的信息标记更易于使用。你可以在Includes.xml中定义它们，或者让它们保持独立，你可以把它们放到继承在Includes.xml中的另外一个文件。你可以通过添加这样的一行继承一个文件：  

```xml
<include file="Variables.xml" />
```

Variables can be used in any tag that supports infolabels, like the texture, label and visible tags. Instead of having to include two whole controls with a condition, they allow you to just apply the condition to the actual texture or label. Meaning less controls to maintain ect. The values in the variable are read from top to bottom and the first condition that is met gets used. The last value usually has no condition and it's content acts as a fallback. The following example shows the album label if the player has audio, the year if there is no audio and no fallback is used (because there either is or is not any audio).  

variable可以用在任何支持信息标记的标签中，比如texture，label和visible标签。与应用两个完整的带有条件的控制相反，它们允许你把条件应用到实际的texture或者label上。同时也意味着更少的标签维护。variable中的value从上至下进行读取，使用第一个遇到的条件。最后一个value通常没有条件，其内容作为回滚。在下面的例子中，如果播放器中没有音频会显示album标记，如果没有音频也没有使用回滚的则显示year标记（因为此处要么有音频要么没有音频）。  

```xml
<variable name="Example">
        <value  condition="Player.HasAudio">$INFO[ListItem.Album]</value>
        <value  condition="!Player.HasAudio">$INFO[ListItem.Year]</value>
        <value>-</value>
</variable>
```

You can use a variable in a label control like this:  

你可以在标记控制中像这样使用变量：  

```xml
<label>$VAR[Example]</label>
```

or when the viariable value is likely to contain commas (,) and/or quotes ("):  

或者在变量的值包含逗号，或者双引号时急性转义：  

```xml
<label>$ESCVAR[Example]</label>
```

(see $ESCINFO[] for more info on the need to escape strings: http://kodi.wiki/view/Label_Parsing)   
更多关于需要转移字符串的

## 5.3 Constants

In case you want to re-use a certain value multiple times in your skin, you can define a constant for it:  

某些情况下你想要在皮肤中重复多次使用某些值，因此你可以定义一个constant：  

```xml
<constant name="FanartCrossfadeTime">300</constant>
<constant name="IconCrossfadeTime">300</constant>
```

you can now reference this value by it's name elsewhere in your skin:  

现在你可以皮肤中的其他地方通过名称引用这个值：  

```xml
<control type="image">
        <left>0</left>
        <top>0</top>
        <width>256</width>
        <height>256</height>
        <texture background="true">$INFO[ListItem.Icon]</texture>
        <fadetime>IconCrossfadeTime</fadetime>
</control>
```

## 5.4 Defaults
for every control type, you can define a default template. for instance here's a template for a button control:  

对于每一种控制类型，你都可以定义一个默认模板。例如，这里是一个按钮控制的模板：  

```xml
<default type="button">
        <left>0</left>
        <top>0</top>
        <width>700</width>
        <height>40</height>
        <label>-</label>
        <texturefocus border="20">list-focus.png</texturefocus>
        <texturenofocus border="20">list-nofocus.png</texturenofocus>
        <font>font20</font>
        <textcolor>white</textcolor>
        <focusedcolor>blue</focusedcolor>
        <disabledcolor>darkgrey</disabledcolor>
        <invalidcolor>red</invalidcolor>
        <textoffsetx>10</textoffsetx>
        <aligny>center</aligny>
        <pulseonselect>true</pulseonselect>
</default>
```

the benefit of defining defaults is that kodi will use the template everywhere in you skin where a button is used, so you don't have to code all of the tags for each and every button. you only have to code the tags that you want to differ from the default template.   

定义default的好处在于，Kodi会在皮肤中的使用了按钮的所有地方使用模板，所以你没有必要为每个按钮编写全部的标签。你唯一必须要做的是编写想要使用的标签不能和默认模板相同。  

## 5.5 Expressions 表达式

expressions are useful if you need to use a certain boolean expression several times throughout your skin. they can be defined in your includes file like this:  

如果你想要对整个皮肤多次使用某些布尔值表达式时，expression就显得很有用了。它们在继承中可以如此定义：  

```xml
<expression name="HasInfoDialog">Window.IsActive(musicinformation) | Window.IsActive(movieinformation) | Window.IsActive(addoninformation)</expression>
<expression name="PluginAdvancedLauncher">substring(Container.FolderPath,plugin://plugin.program.advanced.launcher/,left)</expression>
```

to use an expression in your skin, you can reference them using $EXP[]  

要在皮肤中使用expression，捏可以使用$EXP[]引用它们：  

```xml
<animation condition="$EXP[HasInfoDialog]" effect="fade" start="100" end="0" time="200" tween="sine">Conditional</animation>
<visible>$EXP[PluginAdvancedLauncher] + !Window.IsActive(Home)</visible>
```

expressions can be used in the following tags/attributes:  
expressions可以用在以下标签／属性中：  

- visible
- enable
- usealttexture
- selected
- condition

# 6 Controls

Controls are the substance of your skin. They define everything from buttons, to text labels, to visualization placement. This portion of the manual will explain each and every control in detail.  

控制是皮肤的本质基础。它们定义了一切内容，从按钮到文本标签，再到可视化布局。手册的这一部分会详细说明具体的每一个控制。  

## 6.1 Label Control

The label control is used for displaying text in XBMC. You can choose the font, size, colour, location and contents of the text to be displayed.  

控制标签用来在XBMC中显示文本。你可以选择字体、大小、色彩、位置和需要显示的文本内容。  

### 6.1.1 Example

```xml
  <control type="label" id="1">
        <description>My First label</description>
        <left>80</left>
        <top>60</top>
        <width>250</width>
        <visible>true</visible>
        <align>center</align>
        <aligny>center</aligny>
        <scroll>false</scroll>
        <label>6</label>
        <info>MusicPlayer.Artist</info>
        <number></number>
        <angle>30</angle>
        <haspath>false</haspath>
        <font>font14</font>
        <textcolor>FFB2D4F5</textcolor>
        <shadowcolor>ff000000</shadowcolor>
        <wrapmultiline>false</wrapmultiline>
        <scrollspeed>50</scrollspeed>
        <scrollsuffix> - </scrollsuffix>
  </control>
```

### 6.1.2 Auto size labels 自动尺寸标签
Wrapping your label in a grouplist with the auto width and appropriate minium and maximum values. Allows the labels width to dynamically change relevalant to how long the label text is. This allows a image or other control to be alligned to the right of the actual label text no matter how wide the label is.  

该标签能够把grouplist中的标记应用自动的宽度以及适合的最小、最大值。

```xml
   <width min="29" max="200">auto</width>
```

As of XBMC Gotham, simply specifying <width>auto</width> is also supported.  

从XBMC的Gotham版本开始，简单的指定<width>auto</width>也是可以的。  

### 6.1.3 Multi-line labels 多行标签
If you want your label control to span multiple lines, you can insert a new line character in your label. For example:  

如果你想让标签跨越多行，你可以再标签中插入一个换行字符。例如：  

```xml
   <label>This will be on the first line[CR]And this will be on the second line</label>
```

Also, if you want your label control to conform to the <width> parameter, but still want to be able to give it more content than will fit on one line, then setting:  

此外，如果你想要标签控制认可<width>，而且还想要在一行中添加更多的内容，那么可以设置：  

```xml
   <wrapmultiline>true</wrapmultiline>
```

will cause the text to be cut up (at the spaces in the text) onto multiple lines. Note that if a single word is larger than <width> then it will not be cut, and will still overflow.  

但是这样做鹄引发文本被切分到多行。注意如果单个单词大于<width>，那么文本并不会被切分，而是依旧滚动显示。  

### 6.1.4 Available tags 可用的标签
In addition to the [Default Control Tags](http://kodi.wiki/view/Default_Control_Tags) the following tags are available. Note that each tag is lower case only. This is important, as xml tags are case-sensitive.  

除了默认控制标签之外还可以使用以下标签。注意每个标签仅支持小写。这很重要，因为xml标签都是大小写敏感的。  

|Tag | Description|
|--:|----------:|
|align| Can be left, right, or center. Aligns the text within the given label <width>. Defaults to left |
|aligny|  Can be top or center. Aligns the text within its given label <height>. Defaults to top|
|scroll|  When true, the text will scroll if longer than the label's <width>. If false, the text will be truncated. Defaults to false. |
|label| Specifies the text which should be drawn. You should specify an entry from the strings.xml here (either the Kodi strings.xml or your skin's strings.xml file), however you may also hardcode a piece of text also if you wish, though of course it will not be localisable. You can use the full label formatting syntax and you may also specify more than one piece of information here by using the $INFO and $LOCALIZE formats. |
|info|  Specifies the information that should be presented. Kodi will auto-fill in this info in place of the <label>. See here for more information.|
|number|  Specifies a number that should be presented. This is just here to allow a skinner to use a number rather than a text label (as any number given to <label> will be used to lookup in strings.xml)|
|angle| The angle the text should be rendered at, in degrees. A value of 0 is horizontal.|
|haspath| Specifies whether or not this label is filled with a path. Long paths are shortened by compressing the file path while keeping the actual filename full length.|
|font|  Specifies the font to use from the font.xml file.|
|textcolor| Specifies the color the text should be, in hex AARRGGBB format, or a name from the colour theme.|
|shadowcolor| Specifies the color of the drop shadow on the text, in AARRGGBB format, or a name from the colour theme.|
|wrapmultiline| If true, any text that doesn't fit on one line will be wrapped onto multiple lines.  如果该标签值为true，任何不能适应在单行的文本都会被包装到多行。|
|scrollspeed| Scroll speed of text in pixels per second. Defaults to 60.  按照像素每秒的文本滚动速度。默认为60.|
|scrollsuffix|  Specifies the suffix used in scrolling labels. Defaults to " | ".  指定|

|标签 |描述 |
|:--|:---|
|align|可以是左、右或者中心。排列已有<width>。默认为左。|
|aligny||
|scroll|当该值为true时，如果文本长度大于label的<width>时，文本就会滚动。如果为false，那么文本会被删减。默认值为false。|
|label|指定应该显示的文本。你应该在strings.xml（要么是Kodi的strings.xml 要么是自己皮肤中的strings.xml文件）中指定一个条目，但是如果你喜欢的话，你可以硬编码一段文本，当然这段文本并不会本地存储。你可以使用完整的label格式语法，而且这里你还可以使用$INFO和$LOCALIZE格式化指定不止一段信息。|
|info|指定应该显示的信息。Kodi会在放置<label>的地方自动填充改信息。|
|number||
|angel||
|haspath||


## 6.2 Fade Label Control 可控渐隐标签

The fade label control is used for displaying multiple pieces of text in the same space in Kodi. You can choose the font, size, colour, location and contents of the text to be displayed. The first piece of information to display fades in over 50 frames, then scrolls off to the left. Once it is finished scrolling off screen, the second piece of information fades in and the process repeats. A fade label control is not supported in a list container.  

可控渐隐标签用来显示Kodi中的相通空间的多个文本块。你可以选择文本需要显示的字体、大小、色彩、位置和内容。被显示的第一个信息块的渐隐超过50贞，然后滚动至左边。一旦滚动屏幕结束，然后第二个信息块渐入，之后的信息块依次重复执行。在列表容器中并不支持可控渐隐标签。  

### 6.2.1 Example 示例

```xml
  <control type="fadelabel" id="1">
        <description>My First fadelabel</description>
        <left>80</left>
        <top>60</top>
        <width>250</width>
        <visible>true</visible>
        <scrollout>true</scrollout>
        <pauseatend>200</pauseatend>
        <label>6</label>
        <info>MusicPlayer.Genre</info>
        <info>MusicPlayer.Artist</info>
        <info>MusicPlayer.Album</info>
        <info>MusicPlayer.Year</info>
        <font>font14</font>
        <textcolor>FFB2D4F5</textcolor>
        <textoffsetx>20</textoffsetx>
        <scroll>true</scroll>
        <randomize>true</randomize>
  </control>
```

### 6.2.2 Tag descriptions
In addition to the Default Control Tags the following tags are available. Note that each tag is lower case only. This is important, as xml tags are case-sensitive.  

除了默认的控制标签，下面列出了一些可用的标签。注意每个标签仅支持小写。这很重要，就像xml标签是大小写敏感一样。  

|Tags | Description|
|:---:|:----------:|
|label |Specifies the text which should be drawn. You should specify an entry from the strings.xml here, however you may also specify a piece of text yourself if you wish, though ofcourse it will not be localisable. You may also specify more than one piece of information here by using the $INFO and $LOCALIZE formats.   指定哪一个应该被使用。你应该指定|
|info |Specifies the information that should be presented. Kodi will auto-fill in this info in place of the <label>. See here for more information.  指定需要显示的信息。Kodi会在 <label>中自动填充此信息。|
|font | Specifies the font to use from the font.xml file.  指定需要使用的来自font.xml文件的字体。|
|textcolor| Specified the color the text should be, in hex AARRGGBB format, or a name from the colour theme.  指定文本的要应用的色彩，使用AARRGGBB形式十六进制，或者是基于色彩主题的名称。|
|textoffsetx| Specify the offset from the left edge that the text should be rendered at when static (not scrolling). The scrolling text will still scroll using the full <width> of the control.|
|shadowcolor |Specifies the color of the drop shadow on the text, in AARRGGBB format, or a name from the colour theme.|
|angle | Specifies the angle at which the text should be drawn, measured counter clockwise from the horizontal.|
scrollout If set to False the fadelabel will only scroll until the last char is to the right side of the width of the fadelabel instead of all the way out to the left.
pauseatend  Specifies the time that the text will wait until it fades away before it scrolls again or moves to the next item.
resetonlabelchange  If set to false the fadelabel will not reset the scrolling offset when the label's content changes. Useful if you have things such as the play time (in seconds) inside a fadelabel. Defaults to true.
scrollspeed Scroll speed of text in pixels per second. Defaults to 60.
scroll  If set to false, the labels won't scroll. Defaults to true.
randomize If set to true, the labels will be displayed in a random order. Defaults to false.

|标签 | 描述|
|:---|:----------|
|label||

## 6.3 Button Control 控制按钮

The button control is used for creating push buttons in Kodi. You can choose the position, size, and look of the button, as well as choosing what action(s) should be performed when pushed.  

控制按钮用来在Kodi中创建按压按钮。你可以选择按钮的位置、大小、以及外观，当然也可以选择在按压时应该执行的动作。  

### 6.3.1 Example

```xml
<control type="button" id="1">
      <description>My first button control</description>
      <left>80</left>
      <top>60</top>
      <width>250</width>
      <height>200</height>
      <visible>true</visible>
      <colordiffuse>FFFFFFFF</colordiffuse>
      <texturefocus colordiffuse="FFFFAAFF">myfocustexture.png</texturefocus>
      <texturenofocus colordiffuse="FFFFAAFF">mynormaltexture.png</texturenofocus>
      <label>29</label>
      <wrapmultiline>true</wrapmultiline>
      <font>font12</font>
      <textcolor>FFFFFFFF</textcolor>
      <focusedcolor>FFFFFFFF</focusedcolor>
      <disabledcolor>80FFFFFF</disabledcolor>
      <invalidcolor>FFFFFFFF</invalidcolor>
      <align></align>
      <aligny></aligny>
      <textoffsetx></textoffsetx>
      <textoffsety></textoffsety>
      <pulseonselect></pulseonselect>
      <onclick>XBMC.ActivateWindow(MyVideos)</onclick>
      <onfocus>-</onfocus>
      <onunfocus>-</onunfocus>
      <onup>2</onup>
      <ondown>3</ondown>
      <onleft>1</onleft>
      <onright>1</onright>
</control>
```

### 6.3.2 Available tags
In addition to the Default Control Tags the following tags are available. Note that each tag is lower case only. This is important, as xml tags are case-sensitive.  

除了默认控制标签还有以下可用标签。注意每个标签仅支持小写。这很重要，就像xml标签是大小写敏感一样。  

|Tag 标签 | Description 描述|
|:--|:----------|
|texturefocus|  Specifies the image file which should be displayed when the button has focus. [See here for additional information about textures](http://kodi.wiki/view/Texture_Attributes).  指定在按钮聚焦时应该显示的图片文件。|
|texturenofocus|  Specifies the image file which should be displayed when the button does not have focus.  指定在按钮失焦时应该显示的图片文件。|
|label| The label used on the button. It can be a link into strings.xml, or an actual text label.  用在按钮上的标签。它可以链接到strings.xml文件，或者一个世纪的文本标签。|
|font|  Font used for the button label. From fonts.xml.  |
|textcolor| Color used for displaying the button label. In AARRGGBB hex format, or a name from the colour theme.|
|focusedcolor|  Color used for the button label when the button has in focus. In AARRGGBB hex format or a name from the colour theme.|
|disabledcolor| Color used for the button label if the button is disabled. In AARRGGBB hex format or a name from the colour theme.|
|invalidcolor|  Color used for the button if the user entered some invalid value. In AARRGGBB hex format or a name from the colour theme.|
|shadowcolor| Specifies the color of the drop shadow on the text, in AARRGGBB format, or a name from the colour theme.|
|angle| The angle the text should be rendered at, in degrees. A value of 0 is horizontal.|
|align| Label horizontal alignment on the button. Defaults to left, can also be center or right.|
|aligny|  Label vertical alignment on the button. Defaults to top, can also be center.  垂直排列的在按钮上的label。默认为上，还可以在中心。|
|textoffsetx| Amount to offset the label from the left (or right) edge of the button when using left or right alignment.  |
|textoffsety| Amount to offset the label from the top edge of the button when using top alignment.|
|textwidth| Will truncate any text that's too long.  如果文本太长将被删减。|
|onclick| Specifies the action to perform when the button is pressed. Should be a built in function. See here for more information. You may have more than one <onclick> tag, and they'll be executed in sequence. 按钮被按压时要执行的动作。应该为内建函数。参见这里的更多信息。你可以使用多个<onclick>标签，它们会顺序执行。|
|onfocus| Specifies the action to perform when the button is focused. Should be a built in function. The action is performed after any focus animations have completed. See here for more information.  指定在按钮聚焦时会执行的动作。应为内建函数。|
|onunfocus| Specifies the action to perform when the button loses focus. Should be a built in function.|
|wrapmultiline| Will wrap the label across multiple lines if the label exceeds the control width.|

## 6.4 Image Control 图片控制

The image control is used for displaying images in XBMC. You can choose the position, size, transparency and contents of the image to be displayed.  

图片控制用来在XBMC中显示图片。你可以选择位置、尺寸、透明、需要显示的图片内容。   

### 6.4.1 Example 示例

```xml
<control type="image" id="1">
      <description>My first image control</description>
      <left>80</left>
      <top>60</top>
      <width>250</width>
      <height>200</height>
      <visible>true</visible>
      <colordiffuse>FFFFFFFF</colordiffuse>
      <fadetime>200</fadetime>
      <texture border="5" flipy="true" flipx="false">mytexture.png</texture>
      <bordertexture border="5">mybordertexture.png</bordertexture>
      <bordersize>5</bordersize>
      <texture>$INFO[MusicPlayer.Cover]</texture>
      <aspectratio>keep</aspectratio>
</control>
```

### 6.4.2 Image Size and Type Restrictions
For the <texture> tags, and for all <texture> tags in other controls, there is a small set of rules that you should follow if at all possible:  

#### 6.4.2.1 Size
Images can be any size, though some graphics cards allow only power of 2 textures, so this may be a consideration. For the most case, it doesn't really matter what size things are - Kodi will quite happily load most files.  





# 7 Filling containers 填充容器
## 7.1 Filling containers with static content 利用静态内容填充容器
Container controls (the List Container, Fixed List Container, Wrap List Container, and Panel Container) can be setup by the skinner with some predefined static content. This is done by including the <content> tag in the control. This allows skinners to have lists (or panels) of buttons wherever they want in the skin. The content below could be made separate in a different file for user editting, allowing users to have control over what goes on their home page for instance. You can use <defaultcontrol [always="true"]>id</defaultcontrol> to control which item in the list gets focssed by default.  

容器控制（List容器，Fixed List容器，Wrap List容器，以及Panel容器）的设置可以通过皮肤开发者预定义的一些静态内容完成。

### 7.1.1 Example 示例

```xml
<content>
  <item id="1">
    <label>My First Item</label>
    <label2>Label 2</label2>
    <icon>icon1.png</icon>
    <thumb>thumb1.png</thumb>
    <onclick>ActivateWindow(Home)</onclick>
    <visible>true</visible>
    <property name="foo">Some1stValueHere</property>
    <property name="foo2">Some2ndValueHere</property>
  </item>
  <item id="2">
    <label>My Second Item</label>
    <label2>Label 2</label2>
    <icon>icon2.png</icon>
    <thumb>thumb2.png</thumb>
    <onclick>ActivateWindow(MyMusicLibrary)</onclick>
    <property name="foo">Some1stValueHere</property>
    <property name="foo2">Some2ndValueHere</property>
  </item>
</content>
```

### 7.1.2 Available tags
The available XML tags for each item are as follows. Note that, as always, they're lower-case only, as XML is case-sensitive.  

|Tag| Description|
|id | The id of the item. Useful for external visibility conditions such as Container.HasFocus(3).|
|label |The main label of the item. You can reference this within the <itemlayout> of the list via ListItem.Label.|
|label2 | The secondary label of the item. You can reference this within the <itemlayout> of the list via ListItem.Label2.|
|icon | The icon of the item. You can reference this within the <itemlayout> of the list via ListItem.Icon, or ListItem.ActualIcon.|
|thumb | The thumbnail image of the item. You can reference this within the <itemlayout> of the list via ListItem.Thumb.|
|onclick | The action to be performed when this item is clicked. Should be a built in function. See here for more information.|
|visible | Specifies a condition as to when this item will be visible within the container. Can be true, false, or a condition. See here for more information. Defaults to true.|
|property | Property of the item. You can reference this within the <itemlayout> of the list via ListItem.Property(name).|

## 7.2 Filling containers with dynamic content

Container controls (the List Container, Fixed List Container, Wrap List Container, and Panel Container) can be setup by the skinner with dynamic content from a path or plugin. This is done by including the <content> tag in the control. It saves many lines of code as it's not necessary anymore to use static items for i.e. recently added movies.  

### 7.2.1 Examples
Content filled from a plugin  

```xml
<content>plugin://plugin.test.me?arg1=foo</content>
```

Content filled from a path  

```xml
<content target="music" sortby="artist" sortorder="ascending" limit="10">musicdb://recentlyaddedalbums/</content>
```

### 7.2.2 Available attributes
The available XML attributes for the content tag are as follows. Note that, as always, they're lower-case only, as XML is case-sensitive.  

|Attributes | Description |
|target | Specifies the context window of the content. This is only necessary for folder items as it defines which window should be activated. For example musicdb://albums/ should have target="music" but musicdb://songs/ does not need a target because it contains only songs which will be played via PlayMedia(...) rather than opened via ActivateWindow(target,path,return)|
|limit | Limits the number of items in the container.|
|sortby | Sorts the list by the given value.|
|sortorder | Sort direction of the list: ascending or descending.|

### 7.2.3 Available item properties (can be filled in plugins)
|Property | Description|
|node.target | Specifies the context window of the content. This overwrites the target attribute of the content tag.|
|node.target_url |Overwrites the path of an item if it's clicked on. This can be used to show the content of the item's path in another container while entering a different path if the item is clicked on. An example would be Confluence's home screen where Movies shows the items of it's path as a submenu below while clicking the item always takes the user to movie titles.|

### 7.2.4 Override onclick action
You can define a custom <onclick> action for lists with dynamic content.  

```xml
<control type="list">
    ...
    <onclick>some_builtin</onclick>
    ...
    <content>...</content>
</control>
```

#8 Conditional_Visibility

Kodi's skinning engine versatility is based upon the fact that the skinner can display and hide portions of the skin using a variety of conditional statements that can be combined to create very user friendly UI implementations. For further information of available variable and how they can be applied.  

Kodi皮肤引擎的多功能基于皮肤开发者能够使用

All controls can now benefit from “conditional visibility” support. This means that, instead of specifying just “yes” or “no” for the <visible> tag, you can now provide one of the many preset boolean conditions. Not only that, you can also specify how Kodi should transistion between a visible state and a hidden state.  

所有控制都能从“可见条件”中获益。这就意味着，与仅仅为<visible>标签指定“yes”或者“no”相反，现在你可以提供多个预先设置的布尔条件中的一个。不仅仅如此，你还可以指定Kodi如何在可见状态和隐藏状态之间切换。  

For example, the Project Mayhem 3 skin has <visible>!Player.HasMedia</visible> tags on all the background images on the home page. The reason is that we don't want the images being displayed while a media file (audio or video) is playing or paused, as the video or visualisation will cover the images anyway, so they only take up memory unnecessarily. They also slow down navigation, as the need to be loaded/unloaded depending on whether they are visible (ie whether or not the user has a particular button focused).  

例如，

## 8.1 How They Work

The condition given in the <visible> tag is evaluated at during the control's Render() function. Kodi decides whether or not the condition is true, and updates the control's visibility accordingly. Thus, it all happens without Kodi having to do the extra chores of maintaining which controls need to be shown at which points in time. The controls automatically update themselves.  

## 8.2 Conditional Visibility for Dialogs

Dialogs can also be made to popup automatically based on a visibility condition. This is done by supplying the <visible> tag at the top of the window file (where the <id>, <type> and <coordinate> tags are). Kodi once again evaluates this visibility at render time, and if needbe, will create and show the dialog at the appropriate time. It'll also close them once that visibility has vanished.  

对话框还可以基于可见条件自动地弹出。

This only works with dialogs. For custom windows, you can specify the type of window you require by specifying it using the <type> tag. For more information see the window .xml structure page.  

## 8.3 Combining Conditions 联合条件

You can combine two (or more) of the above settings by using "+" as an AND operator, "|" as an OR operator, “!" as a NOT operator, and "[" and "]" to bracket expressions. For example, <visible>Player.HasVideo + Player.Rewinding8x</visible> will only show the control when the player is rewinding a video at 8x, whereas <visible>Player.HasVideo | Player.IsRecording</visible> will show the control if a video is playing, or if we are recording something. The AND operator takes precedence over the OR operator when evaluating the logic, and operators are read from left to right. So if you want to show something when condition1 OR condition2 is true AND condition3 is true, you can do:  

```xml
<visible>[condition1 | condition2] + condition3</visible>
```

Note that if you missed the brackets, then it would actually be reading «if condition1 or (condition2 and condition3)" due to AND taking precedence over OR.  

Some pointers on boolean logic:  

The following holds true:  

```
A + (B | C) = A + B| A + C
A | (B + C) = (A | B) + (A | C)
```

```
!(A + B) =! A |! B
!(A | B) =! A +! B
```

A common mistake is to do something like this:  

```
! A |! B |! C
```

This is false only if A, B and C are all simultaneously true (as it's the same as !(A + B + C)), and you may have possibly been after  

```
! A +! B +! C
```

which is false if A is true, or B is true, or C is true.  

One thing you will notice, is that when a control is hidden, it can't be focused. This means you can't move to a control and have it automatically become visible (eg even if it had Control.HasFocus(myID) it wouldn't come back on, as Kodi wouldn't allow navigation to the hidden control). To solve this issue, you can use:  

```xml
  <visible allowhiddenfocus="true">Control.HasFocus(21)</visible>
```

on a control of <id> 21. This will allow the control to be focusable even when it's hidden. When the user moves to the hidden control, it will automatically unhide itself, due to the Control.HasFocus(21) visibility condition.  

## 8.4 See also

Development:
Add-on development
Skinning

# 9 Animations

The Kodi skinning engine supports animations of any control allowing them to rotate, slide, fade or any combination there-of. Combining animations with conditional statements ensure your skin will have stunning effects that appear as professional as a 1st party product.  

## 9.1 Animating Your Skin

The Kodi skin engine has support for animations between control and window states. The animations are defined through use of the <animation> tag, which has a defined type and various attributes that specify the animation to be performed. All animations are additive – if two of them are in effect at the same time, their effects are added together. You may also have more than one animation of each type.  

## 9.2 Window Animations

There are two valid window animations – the animation to perform when the window is opened, and the animation to perform when the window is closed. They take the same format as the control animations. You can, however, have more than one animation performed for the WindowOpen or WindowClose animation.  

## 9.3 Control Animations

There are 6 valid control animations: WindowOpen, WindowClose, Visible, Hidden, Focus, and Unfocus. There is also a combination animation VisibleChange that constructs the Visible animation, then reverses it for the Hidden animation.  

有六种有效的control动画：WindowOpen, WindowClose, Visible, Hidden, Focus, 和 Unfocus。

## 9.4 Format of Animation Tags

The animation tag is formatted as follows for a single animation:  

```xml
<animation effect="EFFECT" attributes>TYPE</animation>
```

and as follows for multiple animations:  

```xml
<animation type="TYPE" condition="Window.IsActive(Home)" reversible="false">
  <effect type="EFFECT" other_attributes />
   ...
  <effect type="EFFECT" other_attributes />
</animation>
```

### 9.4.1 Types
The type can be one of the following:  

**WindowOpen**  
Performed once only when the window is opened.  

**WindowClose**  
Performed once only when the window is closed. No animation is performed when switching to fullscreen video, however.  

**Visible**
Performed when the control becomes visible via its <visible> tag.  

**Hidden**
Performed when the control becomes hidden via its <visible> tag.  

Focus
Performed when the control gains focus.
Unfocus
Performed when the control loses focus.
Conditional
Performed when the control's condition attribute is filled.
VisibleChange
The same as the Visible type, except the reverse animation is auto-created for the Hidden type. Just saves having to have both animations if the animation is the same in both directions (ie just reversed)
9.4.2 Attributes
The attributes available are as follows. Note that all attributes, like tags, are case sensitive
effect
Specifies the effect to use. Currently “fade”, “slide”, “rotate”, "rotatex", "rotatey", and “zoom” are supported.
rotatex - rotates a control around the X-Axis (horizontal)
rotatey - rotates a control around the Y-Axis (vertical)
rotate - rotates a control around the Z-Axis
time 
Specifies the length of time that the animation will run, in milliseconds.
delay
The time to delay the transistion before starting it, in milliseconds.
start
The start state of the control for this transistion.
For fades, this is the opaqueness as a percentage (ie start="100" is fully opaque, start="0" is fully transparent.
For slides, this is the relative coordinate offset to start the control at (ie start="50,60" will start the control off at 50 pixels to the right, and 60 pixels below it's normal viewing position.
For rotates, this is the starting degree offset from the horizontal. (ie start="30" will start the control off on an angle of 30 degrees from the horizontal).
For zooms, this is the starting size as a percentage. (ie start="50,60" will start the control at 50% of it's horizontal size and 60% of it's vertical size).
Note: With zooms you can also specify the coordinates and dimensions of the texture. (ie start="left,top,width,height").
end
The end state of the control for this transistion. Similar to the start state, except that the end state is always kept after the animation is finished, and until the control changes its state.
acceleration
Amount to accelerate or decelerate during a “slide”, “zoom” or “rotate” transistion. For deceleration, use a negative value. A value of -1 will cause the control to come to rest at its end coordinates. Defaults to 0. (Also see the tween attribute)
center
Center of the rotation or zoom to perform with a “rotate” or “zoom” transistion. This is the coordinates about which the rotation or zoom will take place. eg center="30,50” will mean that all points will revolve around (or zoom from) the (30,50) pixel location. You can set center="auto" to have Kodi automatically zoom from the center of the control.
Center shifts the rotational axis at the level, rotatex - center="y,z" coordinates, rotatey - center="x,z" coordinates, rotate - center="x,y" coordinates
condition
The conditions under which this animation should be performed. Defaults to being always performed. See here for a list of valid conditionals.
reversible
If “false” the animation is not reversed if it is interrupted when it is finished. For instance a Visible animation will normally be reversed (instead of running the Hidden animation) if the control becomes hidden before the visible animation has finished. Setting reversible="false” prevents this behaviour (the Hidden animation will take its place). Defaults to true.
loop
If “true” will make your animation loop. (jump back to the start after it reaches the end)
pulse
If “true” will make your animation pulse. (Bounce back from start to end to start to end .........)
tween
Tween is like an advanced acceleration attribute that can be applied to all animations. Instead of a steady acceleration or deceleration, you can specify curves that the animation should follow. Currently, the engine supports “elastic“, “bounce“, “circle“, “back“, “sine“, “cubic“, “quadratic“ and, the default, “linear“. More information about Tweeners
easing
Easing basically defines the direction of the tween and can be one of “out“, “inout“ and “in“. The default value is “out“. More information about Easing
9.5 Examples

<visible>Player.HasAudio</visible>
<animation effect="fade" time="400">VisibleChange</animation>
This causes Kodi to fade the control in 400 milliseconds between the visible and hidden states. The control will start off hidden, and will fade in over 400ms when you play audio, and when it's finished, it will fade out again over 400ms.
You can also specify different transistion times for transistioning in and out as follows:
<animation effect="fade" time="100">WindowOpen</animation>
<animation effect="fade" time="1000">WindowClose</animation>

This, when used as the animation tag for the ~MusicOSD dialog, will cause it to fade in quickly (in 100ms) when activated and the fade out again slowly (in 1 second (1000ms)) when it's cancelled.
You can also specify that a control should always fade in when the window is opened by using
<animation effect="fade" time="200">WindowOpen</animation>
This specifies that it will always start hidden, but will fade in immediately (over a time of 200ms) when the window is opened.
There is also ability to add delays preceding the transistions. For instance
<animation effect="fade" time="200" delay="200">Hidden</animation>
would mean that the control will fade out after a delay of 200ms. This is useful for "crossfade" effects, where you want the new control to fade in while the old control is still on screen (and then fade the old one out once the new one is completely opaque).
There are also slide effects available.
<animation effect="slide" end="30,0" time="200">Focus</animation>
will slide the control 30 pixels to the right of its normal position when it becomes focused. Note that when it becomes unfocused it will jump back to it's normal position. A Unfocus animation will make it slide back gracefully.
There are also rotate effects available.
<animation effect="rotate" end="30" center="360,288" time="200">Focus</animation>
will rotate the control 30 degrees counter clockwise about the center of a PAL screen (360,288) when the control becomes focused.
And we also have zoom effects.
<animation effect="zoom" end="120" center="360,288" time="200">Focus</animation>
will zoom the control to 120% of its normal size when the control becomes focused, with the zoom centered at the center of a PAL screen (360,288). You can zoom each dimension by different amounts (effectively a stretch operation) as well. To stretch a control an extra 50% horizontally when focused, we can use
<animation effect="zoom" end="150,100" center="360,288" time="200">Focus</animation>
An example of a condition attribute is:
<animation effect="slide" start="-120,0" time="200" condition="Window.Previous(Home)">WindowOpen</animation>
This will cause the slide animation to only be performed if you are coming to this window from the Home window.
An example of a Conditional animation type is:
<animation effect="slide" start="-120,0" time="200" condition="Control.HasFocus(2)">Conditional</animation>
This will cause the slide animation to only be performed when the control with the id of 2 gains focus.
An example of a fade animation with a pulse:
<animation effect="fade" start="20" time="200" condition="Control.HasFocus(2)" pulse="true">Conditional</animation>
This will cause the control to start at 20% opacity and fade to full in 200 milliseconds and fade back to 20% opacity and keeping looping in that fashion
An example of two animations at once:
<animation type="WindowOpen">
 <effect type="fade" start="0" end="100" time="200"/>
 <effect type="zoom" end="150,100" center="auto" time="200" delay="200"/>
</animation>
This will cause the control to fade in over 200 ms, then zoom to 150% it's width from the center of the control.

